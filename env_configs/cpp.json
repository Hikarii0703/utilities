{
  "pure": {
    "prefix": "pure",
    "body": "#include <bits/stdc++.h>\n\nsigned main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n$0\n\n    return 0;\n}"
  },
  "tests": {
    "prefix": "tests",
    "body": "#include <bits/stdc++.h>\n\nvoid solveCase() {\n$0\n}\n\nsigned main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int numTest;\n    std::cin >> numTest;\n\n    while (numTest--) {\n\t\tsolveCase();\n    }\n\n    return 0;\n}\n"
  },
  "db": {
    "prefix": "db",
    "body": "// ====================================================================\n// clang-format off\n#ifdef HKR0703\nvoid _dbpr(int x) { std::cerr << x; } void _dbpr(int64_t x) { std::cerr << x; } void _dbpr(uint64_t x) { std::cerr << x; }\nvoid _dbpr(double x) { std::cerr << x; } void _dbpr(long double x) { std::cerr << x; } void _dbpr(bool x) { std::cerr << (x ? \"true\" : \"false\"); }\nvoid _dbpr(char x) { std::cerr << '\\'' << x << '\\''; } void _dbpr(const char *x) { std::cerr << '\\\"' << x << '\\\"'; } void _dbpr(const std::string &x) { std::cerr << '\\\"' << x << '\\\"'; }\ntemplate <typename T, typename V> void _dbpr(const std::pair<T, V> &x) { std::cerr << '{'; _dbpr(x.first); std::cerr << \", \"; _dbpr(x.second); std::cerr << '}'; }\ntemplate <size_t N> void _dbpr(std::bitset<N> v) { std::cerr << '{'; for (size_t i = 0; i < N; i++) { std::cerr << v[i]; } std::cerr << '}'; }\ntemplate <typename A, typename B, typename C, typename D> void _dbpr(std::tuple<A, B, C, D> p) { std::cerr << '(' << std::get<0>(p) << \", \" << std::get<1>(p) << \", \" << std::get<2>(p) << \", \" << std::get<3>(p) << ')'; }\ntemplate <typename A, typename B, typename C> void _dbpr(std::tuple<A, B, C> p) { std::cerr << '(' << std::get<0>(p) << \", \" << std::get<1>(p) << \", \" << std::get<2>(p) << ')'; }\ntemplate <typename A, typename B> void _dbpr(std::tuple<A, B> p) { std::cerr << '(' << std::get<0>(p) << \", \" << std::get<1>(p) << ')'; }\ntemplate <typename T> void _dbpr(const T &x) { int f = 0; std::cerr << '{'; for (auto &i : x) { std::cerr << (f++ ? \", \" : \"\"), _dbpr(i); } std::cerr << \"}\"; } void dbpr() { std::cerr << \"]\" << std::endl; }\ntemplate <typename T, typename... V> void dbpr(T t, V... v) { _dbpr(t); if (sizeof...(v)) { std::cerr << \", \"; } dbpr(v...); }\n#define debug(x...) std::cerr << \"[\" << #x << \"] = [\"; dbpr(x)\n#else\n#define debug(x...) \"just a little spark of light.\"\n#endif\n// clang-format on\n// ===================================================================="
  },
  "fast": {
    "prefix": "fast",
    "body": "// ====================================================================\n// clang-format off\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nnamespace io {\nusing namespace std;\nstatic const int buf_size = 4096; static unsigned char buf[buf_size]; static int buf_len = 0, buf_pos = 0;\ninline bool isEof() { if (buf_pos == buf_len) { buf_pos = 0, buf_len = fread(buf, 1, buf_size, stdin); if (buf_pos == buf_len) { return 1; } } return 0; }\ninline int getChar() { return isEof() ? -1 : buf[buf_pos++]; }\ninline int peekChar() { return isEof() ? -1 : buf[buf_pos]; }\ninline bool seekEof() { int c; while ((c = peekChar()) != -1 && c <= 32) { buf_pos++; } return c == -1; }\ninline void skipBlanks() { while (!isEof() && buf[buf_pos] <= 32U) { buf_pos++; } }\ninline int readChar() { int c = getChar(); while (c != -1 && c <= 32) { c = getChar(); } return c; }\ninline int readUInt() { int c = readChar(), x = 0; while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return x; }\ntemplate <class T = int> inline T readInt() { int s = 1, c = readChar(); T x = 0; if (c == '-') { s = -1, c = getChar(); } else if (c == '+') { c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return s == 1 ? x : -x; }\ninline double readDouble() { int s = 1, c = readChar(); double x = 0; if (c == '-') { s = -1, c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } if (c == '.') { c = getChar(); double coef = 1; while ('0' <= c && c <= '9') { x += (c - '0') * (coef *= 1e-1), c = getChar(); } } return s == 1 ? x : -x; }\ninline void readWord(char*s) { int c = readChar(); while (c > 32) { *s++ = c, c = getChar(); } *s = 0; }\ninline bool readLine(char*s) { int c = getChar(); while (c != '\\n' && c != -1) { *s++ = c, c = getChar(); } *s = 0; return c != -1; }\nstatic int write_buf_pos = 0;\nstatic char write_buf[buf_size];\ninline void writeChar(int x) { if (write_buf_pos == buf_size) { fwrite(write_buf, 1, buf_size, stdout), write_buf_pos = 0; } write_buf[write_buf_pos++] = x; }\ninline void flush() { if (write_buf_pos) { fwrite(write_buf, 1, write_buf_pos, stdout), write_buf_pos = 0; fflush(stdout); } }\ntemplate <class T> inline void writeInt(T x, char end = 0, int output_len = -1) { if (x < 0) { writeChar('-'), x = -x; } char s[24]; int n = 0; while (x || !n) { s[n++] = '0' + x % 10, x /= 10; } while (n < output_len) { s[n++] = '0'; } while (n--) { writeChar(s[n]); } if (end) { writeChar(end); } }\ninline void writeWord(const char*s) { while (*s) { writeChar(*s++); } }\ninline void writeDouble(double x, int output_len = 0) { if (x < 0) { writeChar('-'), x = -x; } int t = (int)x; writeInt(t), x -= t; writeChar('.'); for (int i = output_len - 1; i > 0; i--) { x *= 10; t = std::min(9, (int)x); writeChar('0' + t), x -= t; } x *= 10; t = std::min(9, (int)(x + 0.5)); writeChar('0' + t); }\nstatic struct buffer_flusher_t { ~buffer_flusher_t() { flush(); } } buffer_flusher;\n};\n#pragma GCC diagnostic pop\n// clang-format on\n// ===================================================================="
  },
  "freopen": {
    "prefix": "freopen",
    "body": "#ifndef HKR0703\n    freopen(\"${TM_FILENAME_BASE}.inp\", \"r\", stdin);\n    freopen(\"${TM_FILENAME_BASE}.out\", \"w\", stdout);\n#endif"
  },
  "modint": {
    "prefix": "modint",
    "body": "// ====================================================================\n// clang-format off\ntemplate <int MOD_> struct modnum {\n    static constexpr int MOD = MOD_;\n    static_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n    using i64 = int64_t;\n    int v;\n    static int minv(int a, int m) { a %= m; assert(a); return a == 1 ? 1 : int(m - i64(minv(m, a)) * i64(m) / a); }\n\npublic:\n    modnum() : v(0) {}\n    modnum(i64 v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n    friend std::istream& operator >> (std::istream& in, modnum& n) { i64 v_; in >> v_; n = modnum(v_); return in; }\n \n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n    modnum inv() const { modnum res; res.v = minv(v, MOD); return res; }\n    friend modnum inv(const modnum& m) { return m.inv(); }\n    modnum neg() const { modnum res; res.v = v ? MOD-v : 0; return res; }\n    friend modnum neg(const modnum& m) { return m.neg(); }\n \n    modnum operator- () const { return neg(); }\n    modnum operator+ () const { return modnum(*this); }\n \n    modnum& operator ++ () { v ++; if (v == MOD) v = 0; return *this; }\n    modnum& operator -- () { if (v == 0) v = MOD; v --; return *this; }\n    modnum& operator += (const modnum& o) { v -= MOD-o.v; v = (v < 0) ? v + MOD : v; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; v = (v < 0) ? v + MOD : v; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(i64(v) * i64(o.v) % MOD); return *this; }\n    modnum& operator /= (const modnum& o) { return *this *= o.inv(); }\n \n    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\ntemplate <typename T> T pow(T a, int64_t b) { assert(b >= 0); T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r; }\nusing mod_t = modnum<int(1e9) + 7>;\n// clang-format on\n// ===================================================================="
  },
  "yc": {
    "prefix": "yc",
    "body": "// ====================================================================\n// clang-format off\nnamespace std {\ntemplate <class Fun>\nclass y_combinator_result {\n    Fun fun_;\npublic:\n    template <class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template <class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n} // namespace std\n// clang-format on\n// ===================================================================="
  },
  "c++17": {
    "prefix": "c++17",
    "body": "// ====================================================================\n// clang-format off\n#if __cplusplus < 201703L\ntemplate <class C> constexpr auto empty(const C& c) -> decltype(c.empty()) { return c.empty(); }\ntemplate <class C> constexpr auto size(const C& c) -> decltype(c.size()) { return c.size(); }\n#endif\n// clang-format on\n// ===================================================================="
  }
}
