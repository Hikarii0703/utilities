snippet pure
#include <bits/stdc++.h>

signed main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

$0

    return 0;
}
endsnippet

snippet tests
#include <bits/stdc++.h>

void solve() {
$0
}

signed main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

	int t;
	std::cin >> t;

	while (t--) {
		solve();
	}

    return 0;
}
endsnippet


snippet db
// ====================================================================
#ifdef LOCAL
void __print(int x) {std::cerr << x;} void __print(long x) {std::cerr << x;} void __print(long long x) {std::cerr << x;} void __print(unsigned x) {std::cerr << x;}
void __print(unsigned long x) {std::cerr << x;} void __print(unsigned long long x) {std::cerr << x;} void __print(float x) {std::cerr << x;}
void __print(double x) {std::cerr << x;} void __print(long double x) {std::cerr << x;} void __print(char x) {std::cerr << '\'' << x << '\'';}
void __print(const char *x) {std::cerr << '\"' << x << '\"';} void __print(const std::string &x) {std::cerr << '\"' << x << '\"';} void __print(bool x) {std::cerr << (x ? "true" : "false");}
template<typename T, typename V> void __print(const std::pair<T, V> &x) {std::cerr << '{'; __print(x.first); std::cerr << ", "; __print(x.second); std::cerr << '}';}
template<size_t N> void __print(std::bitset<N> v) {std::cerr << '{'; for (size_t i = 0; i < N; i++) {std::cerr << v[i];} std::cerr << '}';}
template <typename A, typename B, typename C, typename D> void __print(std::tuple<A, B, C, D> p) {std::cerr << '(' << std::to_string(std::get<0>(p)) << ", " << std::to_string(std::get<1>(p)) << ", " << std::to_string(std::get<2>(p)) << ", " << std::to_string(std::get<3>(p)) << ')';}
template <typename A, typename B, typename C> void __print(std::tuple<A, B, C> p) {std::cerr << '(' << std::to_string(std::get<0>(p)) << ", " << std::to_string(std::get<1>(p)) << ", " << std::to_string(std::get<2>(p)) << ')';}
template <typename A, typename B> void __print(std::tuple<A, B> p) {std::cerr << '(' << std::to_string(std::get<0>(p)) << ", " << std::to_string(std::get<1>(p)) << ')';}
template<typename T> void __print(const T &x) {int f = 0; std::cerr << '{'; for (auto &i: x) std::cerr << (f++ ? ", " : ""), __print(i); std::cerr << "}";} void _print() {std::cerr << "]\n";}
template <typename T, typename... V> void _print(T t, V... v) {__print(t); if (sizeof...(v)) std::cerr << ", "; _print(v...);}
#define debug(x...) std::cerr << "[" << #x << "] = ["; _print(x)
#else
#define debug(x...) "?"
#endif
// ====================================================================
endsnippet

snippet fast
// ====================================================================
template<typename T>void write(T x) {if (x < 0) {putchar('-'); x = -x;} char buf[20], *p = buf; do {*p++ = '0' + x % 10; x /= 10;} while (x); do {putchar(*--p);} while (p > buf);}
template<typename T>void read(T &x) {char c; while (c = getchar(), c <= ' '); bool sign = c == '-'; if (sign)c = getchar(); x = c - '0'; while (c = getchar(), c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + (c - '0');} if (sign)x = -x;}
// ====================================================================
endsnippet

snippet freopen
#ifndef LOCAL
	freopen("`!p snip.rv = snip.basename`.inp", "r", stdin);
	freopen("`!p snip.rv = snip.basename`.out", "w", stdout);
#endif
endsnippet

snippet usaco
#ifndef LOCAL
	freopen("`!p snip.rv = snip.basename`.in", "r", stdin);
	freopen("`!p snip.rv = snip.basename`.out", "w", stdout);
#endif
endsnippet

snippet ch
// ====================================================================
struct custom_hash {static uint64_t splitmix64(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31);} size_t operator()(uint64_t x) const {static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);}};
// ====================================================================
endsnippet

snippet modulo
// ====================================================================
const int MOD = 1e9 + 7;
int add(int a, int b) {int ret = (a % MOD) + (b % MOD); if (ret >= MOD)ret -= MOD; return ret;}
int sub(int a, int b) {int ret = ((a % MOD) - (b % MOD)); if (ret < 0)ret += MOD; return ret;}
int mul(int a, int b) {return (1LL * (a % MOD) * (b % MOD)) % MOD;}
int powmod(int a, int b) {int ret = 1; for (; b; a = mul(a, a), b >>= 1) {if (b & 1)ret = mul(ret, a);} return ret;}
int divide(int a, int b) {return mul(a, powmod(b, MOD - 2));}
// ====================================================================
endsnippet

snippet modint
// ====================================================================
template <int MOD_> struct modnum {
	static constexpr int MOD = MOD_;
	static_assert(MOD_ > 0, "MOD must be positive"); 
private:
	using ll = long long;
	int v;
	static int minv(int a, int m) {
		a %= m;
		assert(a);
		return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);
	}

public:
	modnum() : v(0) {}
	modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
	explicit operator int() const { return v; }
	friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
	friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }
	friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
	friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; } 
	modnum inv() const {
		modnum res;
		res.v = minv(v, MOD);
		return res;
	}
	friend modnum inv(const modnum& m) { return m.inv(); }
	modnum neg() const {
		modnum res;
		res.v = v ? MOD-v : 0;
		return res;
	}
	friend modnum neg(const modnum& m) { return m.neg(); }
	modnum operator- () const {
		return neg();
	}
	modnum operator+ () const {
		return modnum(*this);
	}
	modnum& operator ++ () {
		v ++;
		if (v == MOD) v = 0;
		return *this;
	}
	modnum& operator -- () {
		if (v == 0) v = MOD;
		v --;
		return *this;
	}
	modnum& operator += (const modnum& o) {
		v += o.v;
		if (v >= MOD) v -= MOD;
		return *this;
	}
	modnum& operator -= (const modnum& o) {
		v -= o.v;
		if (v < 0) v += MOD;
		return *this;
	}
	modnum& operator *= (const modnum& o) {
		v = int(ll(v) * ll(o.v) % MOD);
		return *this;
	}
	modnum& operator /= (const modnum& o) {
		return *this *= o.inv();
	}

	friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
	friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
	friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
	friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
	friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
	friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
using Mint = modnum<1000000007>;
// ====================================================================
endsnippet

snippet bigint
// ====================================================================
const int BASE_DIGITS = 9;
const int BASE = 1e9;
struct BigInt {
    int sign;
    std::vector<int> a;
    
    BigInt() : sign(1) {} BigInt(long long v) {*this = v;} BigInt(const std::string& s) { read(s); }
    BigInt& operator = (long long v) { sign = 1; if (v < 0) { sign = -1; v = -v; } a.clear(); for (; v > 0; v = v / BASE) a.push_back(v % BASE); return *this; }
    void read(const std::string& s) { sign = 1; a.clear(); int pos = 0; while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) { if (s[pos] == '-') sign = -sign; ++pos; } for (int i = s.size() - 1; i >= pos; i -= BASE_DIGITS) { int x = 0; for (int j = std::max(pos, i - BASE_DIGITS + 1); j <= i; j++) x = x * 10 + s[j] - '0'; a.push_back(x); } trim(); }
    friend std::istream& operator>>(std::istream &stream, BigInt &v) { std::string s; stream >> s; v.read(s); return stream; }
    friend std::ostream& operator<<(std::ostream &stream, const BigInt &v) { if (v.sign == -1 && !v.isZero()) stream << '-'; stream << (v.a.empty() ? 0 : v.a.back()); for (int i = (int) v.a.size() - 2; i >= 0; --i) stream << std::setw(BASE_DIGITS) << std::setfill('0') << v.a[i]; return stream; }
    
    bool operator<(const BigInt &v) const { if (sign != v.sign) return sign < v.sign; if (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign; for (int i = ((int) a.size()) - 1; i >= 0; i--) if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign; return false; }
    bool operator>(const BigInt &v) const { return v < *this; }
    bool operator<=(const BigInt &v) const { return !(v < *this); }
    bool operator>=(const BigInt &v) const { return !(*this < v); }
    bool operator==(const BigInt &v) const { return !(*this < v) && !(v < *this); }
    bool operator!=(const BigInt &v) const { return *this < v || v < *this; }

    friend int __compare_abs(const BigInt& x, const BigInt& y) {
        if (x.a.size() != y.a.size()) { return x.a.size() < y.a.size() ? -1 : 1; } for (int i = ((int) x.a.size()) - 1; i >= 0; --i) { if (x.a[i] != y.a[i]) { return x.a[i] < y.a[i] ? -1 : 1; } } return 0; }
    
    BigInt operator-() const { BigInt res = *this; if (isZero()) return res; res.sign = -sign; return res; }
    // Note: sign ignored.
    void __internal_add(const BigInt& v) { if (a.size() < v.a.size()) { a.resize(v.a.size(), 0); } for (int i = 0, carry = 0; i < (int) std::max(a.size(), v.a.size()) || carry; ++i) { if (i == (int) a.size()) a.push_back(0); a[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0); carry = a[i] >= BASE; if (carry) a[i] -= BASE; } }
    // Note: sign ignored.
    void __internal_sub(const BigInt& v) { for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) { a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0); carry = a[i] < 0; if (carry) a[i] += BASE; } this->trim(); }
    BigInt operator += (const BigInt& v) { if (sign == v.sign) { __internal_add(v); } else { if (__compare_abs(*this, v) >= 0) { __internal_sub(v); } else { BigInt vv = v; std::swap(*this, vv); __internal_sub(vv); } } return *this; }
    BigInt operator -= (const BigInt& v) { if (sign == v.sign) { if (__compare_abs(*this, v) >= 0) { __internal_sub(v); } else { BigInt vv = v; std::swap(*this, vv); __internal_sub(vv); this->sign = -this->sign; } } else {__internal_add(v); } return *this; }
    // Optimize operators + and - according to
    // https://stackoverflow.com/questions/13166079/move-semantics-and-pass-by-rvalue-reference-in-overloaded-arithmetic
    template<typename L, typename R> typename std::enable_if<std::is_convertible<L, BigInt>::value && std::is_convertible<R, BigInt>::value && std::is_lvalue_reference < R&& >::value, BigInt>::type friend operator + (L&& l, R&& r) { BigInt result(std::forward<L>(l)); result += r; return result; }
    template<typename L, typename R> typename std::enable_if<std::is_convertible<L, BigInt>::value && std::is_convertible<R, BigInt>::value && std::is_rvalue_reference < R&& >::value, BigInt>::type friend operator + (L&& l, R&& r) { BigInt result(std::move(r)); result += l; return result; }
    template<typename L, typename R> typename std::enable_if<std::is_convertible<L, BigInt>::value && std::is_convertible<R, BigInt>::value, BigInt>::type friend operator - (L&& l, R&& r) { BigInt result(std::forward<L>(l)); result -= r; return result; }
    
    friend std::pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) { assert(b1 > 0); long long norm = BASE / (b1.a.back() + 1); BigInt a = a1.abs() * norm; BigInt b = b1.abs() * norm; BigInt q = 0, r = 0; q.a.resize(a.a.size()); for (int i = a.a.size() - 1; i >= 0; i--) { r *= BASE; r += a.a[i]; long long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()]; long long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1]; long long d = ((long long) BASE * s1 + s2) / b.a.back(); r -= b * d; while (r < 0) { r += b, --d; } q.a[i] = d; } q.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim(); auto res = std::make_pair(q, r / norm); if (res.second < 0) res.second += b1; return res; }
    BigInt operator/(const BigInt &v) const { return divmod(*this, v).first; }
    BigInt operator%(const BigInt &v) const { return divmod(*this, v).second; }
    void operator/=(int v) { assert(v > 0); if (llabs(v) >= BASE) { *this /= BigInt(v); return; } if (v < 0) sign = -sign, v = -v; for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) { long long cur = a[i] + rem * (long long) BASE; a[i] = (int) (cur / v); rem = (int) (cur % v); } trim(); }
    BigInt operator/(int v) const { assert(v > 0); if (llabs(v) >= BASE) { return *this / BigInt(v); } BigInt res = *this; res /= v; return res; }
    void operator/=(const BigInt &v) { *this = *this / v; }
    long long operator%(long long v) const { assert(v > 0); assert(v < BASE); int m = 0; for (int i = a.size() - 1; i >= 0; --i) m = (a[i] + m * (long long) BASE) % v; return m * sign; } void operator*=(int v) { if (llabs(v) >= BASE) { *this *= BigInt(v); return; } if (v < 0) sign = -sign, v = -v; for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) { if (i == (int) a.size()) a.push_back(0); long long cur = a[i] * (long long) v + carry; carry = (int) (cur / BASE); a[i] = (int) (cur % BASE); } trim(); }
    BigInt operator*(int v) const { if (llabs(v) >= BASE) { return *this * BigInt(v); } BigInt res = *this; res *= v; return res; }
    static std::vector<int> convert_base(const std::vector<int> &a, int old_digits, int new_digits) { std::vector<long long> p(std::max(old_digits, new_digits) + 1); p[0] = 1; for (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10; std::vector<int> res; long long cur = 0; int cur_digits = 0; for (int i = 0; i < (int) a.size(); i++) { cur += a[i] * p[cur_digits]; cur_digits += old_digits; while (cur_digits >= new_digits) { res.push_back((long long)(cur % p[new_digits])); cur /= p[new_digits]; cur_digits -= new_digits; } } res.push_back((int) cur); while (!res.empty() && !res.back()) res.pop_back(); return res; }
    void fft(std::vector<std::complex<double> > & a, bool invert) const { int n = (int) a.size(); for (int i = 1, j = 0; i < n; ++i) { int bit = n >> 1; for (; j >= bit; bit >>= 1) j -= bit; j += bit; if (i < j) std::swap(a[i], a[j]); } for (int len = 2; len <= n; len <<= 1) { double ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1); std::complex<double> wlen(std::cos(ang), std::sin(ang)); for (int i = 0; i < n; i += len) { std::complex<double> w(1); for (int j = 0; j < len / 2; ++j) { std::complex<double> u = a[i + j]; std::complex<double> v = a[i + j + len / 2] * w; a[i + j] = u + v; a[i + j + len / 2] = u - v; w *= wlen; } } } if (invert) for (int i = 0; i < n; ++i) a[i] /= n; }
    void multiply_fft(const std::vector<int> &a, const std::vector<int> &b, std::vector<int> &res) const { std::vector<std::complex<double> > fa(a.begin(), a.end()); std::vector<std::complex<double> > fb(b.begin(), b.end()); int n = 1; while (n < (int) std::max(a.size(), b.size())) n <<= 1; n <<= 1; fa.resize(n); fb.resize(n); fft(fa, false); fft(fb, false); for (int i = 0; i < n; ++i) fa[i] *= fb[i]; fft(fa, true); res.resize(n); long long carry = 0; for (int i = 0; i < n; ++i) { long long t = (long long) (fa[i].real() + 0.5) + carry; carry = t / 1000; res[i] = t % 1000; } }
    BigInt mul_simple(const BigInt &v) const { BigInt res; res.sign = sign * v.sign; res.a.resize(a.size() + v.a.size()); for (int i = 0; i < (int) a.size(); ++i) if (a[i]) for (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) { long long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry; carry = (int) (cur / BASE); res.a[i + j] = (int) (cur % BASE); } res.trim(); return res; }
    typedef std::vector<long long> vll;
    static vll karatsubaMultiply(const vll &a, const vll &b) { int n = a.size(); vll res(n + n); if (n <= 32) { for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j]; return res; } int k = n >> 1; vll a1(a.begin(), a.begin() + k); vll a2(a.begin() + k, a.end()); vll b1(b.begin(), b.begin() + k); vll b2(b.begin() + k, b.end()); vll a1b1 = karatsubaMultiply(a1, b1); vll a2b2 = karatsubaMultiply(a2, b2); for (int i = 0; i < k; i++) a2[i] += a1[i]; for (int i = 0; i < k; i++) b2[i] += b1[i]; vll r = karatsubaMultiply(a2, b2); for (int i = 0; i < (int) a1b1.size(); i++) r[i] -= a1b1[i]; for (int i = 0; i < (int) a2b2.size(); i++) r[i] -= a2b2[i]; for (int i = 0; i < (int) r.size(); i++) res[i + k] += r[i]; for (int i = 0; i < (int) a1b1.size(); i++) res[i] += a1b1[i]; for (int i = 0; i < (int) a2b2.size(); i++) res[i + n] += a2b2[i]; return res; }
    BigInt mul_karatsuba(const BigInt &v) const { std::vector<int> a6 = convert_base(this->a, BASE_DIGITS, 6); std::vector<int> b6 = convert_base(v.a, BASE_DIGITS, 6); vll a(a6.begin(), a6.end()); vll b(b6.begin(), b6.end()); while (a.size() < b.size()) a.push_back(0); while (b.size() < a.size()) b.push_back(0); while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0); vll c = karatsubaMultiply(a, b); BigInt res; res.sign = sign * v.sign; long long carry = 0; for (int i = 0; i < (int) c.size(); i++) { long long cur = c[i] + carry; res.a.push_back((int) (cur % 1000000)); carry = cur / 1000000; } res.a = convert_base(res.a, 6, BASE_DIGITS); res.trim(); return res; }
    void operator*=(const BigInt &v) { *this = *this * v; }
    BigInt operator*(const BigInt &v) const { if (a.size() * v.a.size() <= 1000111) return mul_simple(v); if (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v); return mul_karatsuba(v); }
    BigInt mul_fft(const BigInt& v) const { BigInt res; res.sign = sign * v.sign; multiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a); res.a = convert_base(res.a, 3, BASE_DIGITS); res.trim(); return res; }
    
    BigInt abs() const { BigInt res = *this; res.sign *= res.sign; return res; }
    void trim() { while (!a.empty() && !a.back()) a.pop_back(); if (a.empty()) sign = 1; }
    bool isZero() const { return a.empty() || (a.size() == 1 && !a[0]); }
    friend BigInt gcd(const BigInt &a, const BigInt &b) { return b.isZero() ? a : gcd(b, a % b); }
    friend BigInt lcm(const BigInt &a, const BigInt &b) { return a / gcd(a, b) * b; }
    friend BigInt sqrt(const BigInt &a1) { BigInt a = a1; while (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0); int n = a.a.size(); int firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]); int norm = BASE / (firstDigit + 1); a *= norm; a *= norm; while (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0); BigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2]; firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]); int q = firstDigit; BigInt res; for (int j = n / 2 - 1; j >= 0; j--) { for (; ; --q) { BigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0); if (r1 >= 0) { r = r1; break; } } res *= BASE; res += q; if (j > 0) { int d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0; int d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0; int d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0; q = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2); } } res.trim(); return res / norm; }
};
// ====================================================================
endsnippet

