snippet pure
/*
              ||========||
              || i <3 u ||
              ||========||
            (\__/) || (\__/)
            (•ㅅ•) || (•ㅅ•)
            / 　 つ   /> ❤<\

                彗星の光
*/
#include <bits/stdc++.h>

signed main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

$0

    return 0;
}
endsnippet

snippet tests
/*
              ||========||
              || i <3 u ||
              ||========||
            (\__/) || (\__/)
            (•ㅅ•) || (•ㅅ•)
            / 　 つ   /> ❤<\

                彗星の光
*/
#include <bits/stdc++.h>

void solveCase() {
$0
}

signed main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int numTest;
    std::cin >> numTest;

    while (numTest--) {
		solveCase();
    }

    return 0;
}
endsnippet

snippet db
// ====================================================================
// clang-format off
#ifdef HKR0703 // this looks like a pile of trash tbh
#define ER(...) fprintf(stderr, __VA_ARGS__)
inline void FP(int x) { ER("%d", x); } inline void FP(int64_t x) { ER("%jd", x); } inline void FP(uint64_t x) { ER("%ju", x); } inline void FP(double x) { ER("%lf", x); } inline void FP(long double x) { ER("%Lf", x); } inline void FP(bool x) { ER("%s", (x ? "true" : "false")); }
inline void FP(char x) { ER("\'%c\'", x); } inline void FP(const char *x) { ER("\"%s\"", x); } inline void FP(const std::string &x) { ER("\"%s\"", x.data()); }
template <class T, class V> inline void FP(const std::pair<T, V> &x) { ER("{"); FP(x.first); ER(", "); FP(x.second); ER("}"); }
template <size_t N> inline void FP(std::bitset<N> v) { ER("{"); for (size_t i = 0; i < N; i++) { FP(int(v[i])); } ER("}"); }
template <class A, class B, class C, class D> inline void FP(std::tuple<A, B, C, D> p) { ER("("); FP(std::get<0>(p)); ER(", "); FP(std::get<1>(p)); ER(", "); FP(std::get<2>(p)); ER(", "); FP(std::get<3>(p)); ER(")"); }
template <class A, class B, class C> inline void FP(std::tuple<A, B, C> p) { ER("("); FP(std::get<0>(p)); ER(", "); FP(std::get<1>(p)); ER(", "); FP(std::get<2>(p)); ER(")"); }
template <class T> inline void FP(const T &x) { int f = 0; ER("{"); for (const auto &i : x) { ER(f++ ? ", " : ""); FP(i); } ER("}"); }
inline void DB() { ER("]\n"); fflush(stderr); } template <class T, class... V> inline void DB(T t, V... v) { FP(t); if (sizeof...(v)) { ER(", "); } DB(v...); }
#define debug(x...) ER("[%s] = [", #x); DB(x)
#define fdebug(...) ER(__VA_ARGS__); fflush(stderr)
#define rdebug(x, l, r) assert((l) <= (r)); ER("[%s(%d:%d)] = [", #x, int(l), int(r)); ER("{"); for (int _i = int(l); _i < int(r); _i++) { FP(x[_i]); ER(", "); } FP(x[r]); ER("}]"); fflush(stderr)
#else
#define debug(x...)  ((void)0) // debug
#define fdebug(x...) ((void)0) // formatted debug
#define rdebug(x...) ((void)0) // range debug
#endif
// clang-format on
// ====================================================================
endsnippet

snippet fast
// ====================================================================
// clang-format off
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
namespace io {
using namespace std;
static const int buf_size = 4096; static unsigned char buf[buf_size]; static int buf_len = 0, buf_pos = 0;
inline bool isEof() { if (buf_pos == buf_len) { buf_pos = 0, buf_len = fread(buf, 1, buf_size, stdin); if (buf_pos == buf_len) { return 1; } } return 0; }
inline int getChar() { return isEof() ? -1 : buf[buf_pos++]; }
inline int peekChar() { return isEof() ? -1 : buf[buf_pos]; }
inline bool seekEof() { int c; while ((c = peekChar()) != -1 && c <= 32) { buf_pos++; } return c == -1; }
inline void skipBlanks() { while (!isEof() && buf[buf_pos] <= 32U) { buf_pos++; } }
inline int readChar() { int c = getChar(); while (c != -1 && c <= 32) { c = getChar(); } return c; }
inline int readUInt() { int c = readChar(), x = 0; while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return x; }
template <class T = int> inline T readInt() { int s = 1, c = readChar(); T x = 0; if (c == '-') { s = -1, c = getChar(); } else if (c == '+') { c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return s == 1 ? x : -x; }
inline double readDouble() { int s = 1, c = readChar(); double x = 0; if (c == '-') { s = -1, c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } if (c == '.') { c = getChar(); double coef = 1; while ('0' <= c && c <= '9') { x += (c - '0') * (coef *= 1e-1), c = getChar(); } } return s == 1 ? x : -x; }
inline void readWord(char*s) { int c = readChar(); while (c > 32) { *s++ = c, c = getChar(); } *s = 0; }
inline bool readLine(char*s) { int c = getChar(); while (c != '\n' && c != -1) { *s++ = c, c = getChar(); } *s = 0; return c != -1; }
static int write_buf_pos = 0;
static char write_buf[buf_size];
inline void writeChar(int x) { if (write_buf_pos == buf_size) { fwrite(write_buf, 1, buf_size, stdout), write_buf_pos = 0; } write_buf[write_buf_pos++] = x; }
inline void flush() { if (write_buf_pos) { fwrite(write_buf, 1, write_buf_pos, stdout), write_buf_pos = 0; fflush(stdout); } }
template <class T> inline void writeInt(T x, char end = 0, int output_len = -1) { if (x < 0) { writeChar('-'), x = -x; } char s[24]; int n = 0; while (x || !n) { s[n++] = '0' + x % 10, x /= 10; } while (n < output_len) { s[n++] = '0'; } while (n--) { writeChar(s[n]); } if (end) { writeChar(end); } }
inline void writeWord(const char*s) { while (*s) { writeChar(*s++); } }
inline void writeDouble(double x, int output_len = 0) { if (x < 0) { writeChar('-'), x = -x; } int t = (int)x; writeInt(t), x -= t; writeChar('.'); for (int i = output_len - 1; i > 0; i--) { x *= 10; t = std::min(9, (int)x); writeChar('0' + t), x -= t; } x *= 10; t = std::min(9, (int)(x + 0.5)); writeChar('0' + t); }
static struct buffer_flusher_t { ~buffer_flusher_t() { flush(); } } buffer_flusher;
};
#pragma GCC diagnostic pop
// clang-format on
// ====================================================================
endsnippet

snippet freopen
#ifndef HKR0703
    freopen("`!p snip.rv = snip.basename`.inp", "r", stdin);
    freopen("`!p snip.rv = snip.basename`.out", "w", stdout);
#endif
endsnippet

snippet __freopen
#ifndef HKR0703
    freopen("${TM_FILENAME_BASE}.inp", "r", stdin);
    freopen("${TM_FILENAME_BASE}.out", "w", stdout);
#endif
endsnippet

snippet modint
// ====================================================================
// clang-format off
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, "MOD must be positive");
private:
    using i64 = int64_t; int v;
    static int minv(int a, int m) { a %= m; assert(a); return a == 1 ? 1 : int(m - i64(minv(m, a)) * i64(m) / a); }
public:
    modnum() : v(0) {}
    modnum(i64 v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    // friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { i64 v_; in >> v_; n = modnum(v_); return in; }
 
    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }
 
    modnum inv() const { modnum res; res.v = minv(v, MOD); return res; }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const { modnum res; res.v = v ? MOD-v : 0; return res; }
    friend modnum neg(const modnum& m) { return m.neg(); }
 
    modnum operator- () const { return neg(); }
    modnum operator+ () const { return modnum(*this); }
 
    modnum& operator ++ () { v ++; if (v == MOD) v = 0; return *this; }
    modnum& operator -- () { if (v == 0) v = MOD; v --; return *this; }
    modnum& operator += (const modnum& o) { v -= MOD-o.v; v = (v < 0) ? v + MOD : v; return *this; }
    modnum& operator -= (const modnum& o) { v -= o.v; v = (v < 0) ? v + MOD : v; return *this; }
    modnum& operator *= (const modnum& o) { v = int(i64(v) * i64(o.v) % MOD); return *this; }
    modnum& operator /= (const modnum& o) { return *this *= o.inv(); }
 
    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
template <class T> T pow(T a, int64_t b) { assert(b >= 0); T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r; }
constexpr int MOD_ = 1e9 + 7;
using mod_t = modnum<MOD_>;
// clang-format on
// ====================================================================
endsnippet

snippet util
// ====================================================================
// clang-format off
#if __cplusplus < 201703L
template <class C> constexpr auto empty(const C& c) -> decltype(c.empty()) { return c.empty(); }
template <class C> constexpr auto size(const C& c) -> decltype(c.size()) { return c.size(); }
template <class C> constexpr auto data(const C& c) -> decltype(c.data()) { return c.data(); }
#endif
namespace std { // I mean, these aren't standard but meh
template <class I, class S, class V> inline void iota_n(I f, S N, V val) { std::iota(f, f + N, val); }
template <class I, class S> inline void sort_n(I f, S N) { std::sort(f, f + N); }
template <class I, class S, class C> inline void sort_n(I f, S N, C cmp) { std::sort(f, f + N, cmp); }
} // namespace std
// clang-format on
// ====================================================================
endsnippet
