snippet code
/*
				君のいない　世界にも
				何かの意味はきっとあって

				でも君のいない　世界など
				夏休みのない　八月のよう

				君のいない　世界など
				笑うことない　サンタのよう

				君のいない　世界など...
*/
#define MULTICASE 0
#define FILEIO 0
#define INTERACTIVE 0
#define PRAGMAS 0

#include <bits/stdc++.h>

// template ===========================================================
// *INDENT-OFF*

#if PRAGMAS
#warning "PRAGMAS ON"
#pragma GCC target ("avx2")
#pragma GCC optimize("Ofast", "unroll-loops", "no-stack-protector")
#endif // PRAGMAS

// shorthands

// types
using i64 = long long;
using u64 = unsigned long long;
using uint = unsigned;
using db = double;
using ld = long double;
using str = std::string;

// limits
constexpr int MAX32 = INT_MAX;
constexpr int MIN32 = INT_MIN;
constexpr i64 MAX64 = LLONG_MAX;
constexpr i64 MIN64 = LLONG_MIN;

// pairs
using pi = std::pair<int, int>;
using p64 = std::pair<i64, i64>;
using pdb = std::pair<db, db>;

// vectors of types
using vb = std::vector<bool>;
using vi = std::vector<int>;
using v64 = std::vector<i64>;
using vdb = std::vector<db>;
using vld = std::vector<ld>;
using vstr = std::vector<str>;

// vectors of pairs
using vpi = std::vector<pi>;
using vp64 = std::vector<p64>;
using vpdb = std::vector<pdb>;

// vectors of vectors
using vvi = std::vector<vi>;
using vv64 = std::vector<v64>;
using vvpi = std::vector<vpi>;
using vvp64 = std::vector<vp64>;
using vvb = std::vector<vb>;

// priority_queue -> heap
template <class T, class Cmp = std::less<T>> using maxheap = std::priority_queue<T, std::vector<T>, Cmp>;
template <class T> using minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;

#define all(_x_) (_x_).begin(), (_x_).end()
#define rall(_x_) (_x_).rbegin(), (_x_).rend()
#define bb(_x_) (_x_).begin(), (_x_).begin()
#define rbb(_x_) (_x_).rbegin(), (_x_).rbegin()

// variadic for-loops

// For with type
#define ForTS(T, _i_, _a_, _b_, _c_) for (T _i_ = (_a_); _i_ <= (_b_); _i_ += (_c_))
#define ForTU(T, _i_, _a_, _b_) ForTS(T, _i_, _a_, _b_, 1)
#define ForTN(T, _i_, _n_) ForTS(T, _i_, 0, _n_ - 1, 1)

// Reversed For with type
#define RForTS(T, _i_, _a_, _b_, _c_) for (T _i_ = (_a_); _i_ >= (_b_); _i_ -= (_c_))
#define RForTU(T, _i_, _a_, _b_) RForTS(T, _i_, _a_, _b_, 1)
#define RForTN(T, _i_, _n_) RForTS(T, _i_, _n_ - 1, 0, 1)

// For
#define ForS(_i_, _a_, _b_, _c_) ForTS(int, _i_, _a_, _b_, _c_)
#define ForU(_i_, _a_, _b_) ForS(_i_, _a_, _b_, 1)
#define ForN(_i_, _n_) ForS(_i_, 0, (_n_) - 1, 1)

// Reversed For
#define RForS(_i_, _a_, _b_, _c_) RForTS(int, _i_, _a_, _b_, _c_)
#define RForU(_i_, _a_, _b_) RForS(_i_, _a_, _b_, 1)
#define RForN(_i_, _n_) RForS(_i_, (_n_) - 1, 0, 1)

// For Each
#define ForE1(_a_, _x_) for (auto &_a_ : _x_)
#define ForE2(_a_, _b_, _x_) for (auto &[_a_, _b_] : _x_)
#define ForE3(_a_, _b_, _c_, _x_) for (auto &[_a_, _b_, _c_] : _x_)

#define NumArgsT(_1, _2, _3, _4, _5, ForTFunc, ...) ForTFunc
#define NumArgs(_1, _2, _3, _4, ForFunc, ...) ForFunc
#define NumArgsE(_1, _2, _3, _4, ForEFunc, ...) ForEFunc

#define ForT(...) NumArgsT(__VA_ARGS__, ForTS, ForTU, ForTN) (__VA_ARGS__)
#define RForT(...) NumArgsT(__VA_ARGS__, RForTS, RForTU, RForTN) (__VA_ARGS__)
#define For(...) NumArgs(__VA_ARGS__, ForS, ForU, ForN) (__VA_ARGS__)
#define RFor(...) NumArgs(__VA_ARGS__, RForS, RForU, RForN) (__VA_ARGS__)
#define ForE(...) NumArgsE(__VA_ARGS__, ForE3, ForE2, ForE1) (__VA_ARGS__)
#define Rep(_x_) For(_rep_, _x_)
#define Forever for (;;)

// bit stuff
#define popcnt(x) __builtin_popcountll(x)
#define clz(x) __builtin_clzll(x)
#define ffs(x) __builtin_ffsll(x)
template <class T> bool getBit(T mask, int b) { return (mask >> b & T(1)); }
template <class T> void setBit(T &mask, int b) { mask |= (T(1) << b); }
template <class T> void delBit(T &mask, int b) { mask &= ~(T(1) << b); }
template <class T> void flipBit(T &mask, int b) { mask ^= (T(1) << b); }

// read
template <class A, class B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { return is >> p.first >> p.second; }
template <class T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { int sz = v.size(); for (int i = 0; i < sz; i++) { is >> v[i]; } return is; } 
inline bool re() { return true; }
template <class T, class... A> inline bool re(T &x, A &...a) { return (std::cin >> x) && re(a...); }
inline bool reln(str &s) { return !!getline(std::cin, s); }

// write
template <class A, class B> std::ostream &operator<<(std::ostream &os, const std::pair<A, B> &p) { return os << p.first << ' ' << p.second; }
template <class T> std::ostream &operator<<(std::ostream &os, const std::vector<T> &v) { int sz = v.size(); for (int i = 0; i < sz - 1; i++) { os << v[i] << ' '; } return os << v[sz - 1];} 
template <bool SP = false> inline void wr() {}
template <bool SP = false, class T, class... A> inline void wr(const T &x, const A &...a) { if (SP) std::cout << ' '; std::cout << x; wr<true>(a...); }
template <class... A> inline void wrln(const A &...a) { wr(a...); std::cout << '\n'; if (INTERACTIVE) std::cout << std::flush; }

// container access
#define TEMPL_ELEM(func) template <class C> constexpr inline auto func(C &c) -> decltype(c.func()) { return c.func(); }
TEMPL_ELEM(front) TEMPL_ELEM(back) TEMPL_ELEM(top)
#if __cplusplus < 201703L
TEMPL_ELEM(empty) TEMPL_ELEM(data)
#endif
template <class C> inline void clear(C& c) { c.clear(); }
#undef TEMPL_ELEM

// utilities
template <class A, class B> inline bool chmin(A &t, const B &f) { if (t > f) { t = f; return true; } return false; }
template <class A, class B> inline bool chmax(A &t, const B &f) { if (t < f) { t = f; return true; } return false; }
template <class C> inline void remdup(C &x) { sort(all(x)); x.erase(unique(all(x)), x.end()); }
template <class C> inline i64 len(const C &x) { return static_cast<i64>(x.size()); }
inline const str YN(bool cond) { return static_cast<const str &>((reinterpret_cast<const char *>((& (const int &)(23438671621410638LL >> (cond << 5)))))); }
inline const str yn(bool cond) { return static_cast<const str &>((reinterpret_cast<const char *>((& (const int &)(32481055248248654LL >> (cond << 5)))))); }
template <class I> struct __ { I &v_; explicit __(I &v) : v_{v} {} class I::reverse_iterator begin() const { return v_.rbegin(); } class I::reverse_iterator end() const { return v_.rend(); } };
template <class I> __<I> reversed(I &v) { return __<I>(v); }
template <class I> inline I maxElem(I f, I l) { return std::max_element(f, l); }
template <class I> inline I minElem(I f, I l) { return std::min_element(f, l); }

// debugger
#ifdef LOCAL_DEFINE
namespace std {
using namespace std;
template <class A, class B> string to_string(const std::pair<A, B> &p); template <class A, class B, class C> string to_string(const tuple<A, B, C> &p);
string to_string(const string &s) { return '"' + s + '"'; } string to_string(const char *s) { return to_string(static_cast<string>(s)); }
string to_string(char c) { return "\'" + string(1, c) + "\'"; } string to_string(bool b) { return (b ? "true" : "false"); }
string to_string(const std::vector<bool> &v) { bool first = true; string res = "{"; for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += ", "; } first = false; res += to_string(v[i]); } res += "}"; return res; }
template <size_t N> string to_string(const bitset<N> &v) { string res = ""; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <class A> string to_string(const A &v) { bool first = true; string res = "{"; for (const auto &x : v) { if (!first) { res += ", "; } first = false; res += to_string(x); } res += "}"; return res; }
template <class A, class B> string to_string(const std::pair<A, B> &p) { return "(" + to_string(p.first) + ", " + to_string(p.second) + ")"; }
template <class A, class B, class C> string to_string(const tuple<A, B, C> &p) { return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")"; }
void debug_out() { cerr << endl; } template <class Head, class... Tail> void debug_out(Head H, Tail... T) { cerr << " " << to_string(H); debug_out(T...); }
}
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) "A world without you is..."
#endif // LOCAL_DEFINE

// randomizer
#ifdef LOCAL_DEFINE
std::mt19937_64 rng(0703);
#else
std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
#endif // LOCAL_DEFINE
inline i64 randrange(i64 a, i64 b) { return std::uniform_int_distribution<i64>(a, b)(rng); }

// indexed set
#ifdef PB_DS_ASSOC_CNTNR_HPP
template <class T> using idset = __gnu_pbds::tree<T, __gnu_pbds::null_type, less <T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;
#define ook order_of_key
#define fbo find_by_order
#endif // PB_DS_ASSOC_CNTNR_HPP

// y_combinator
#if __cplusplus >= 201402L
namespace std {
template <class Fun>
class ___ {
	Fun fun_;
public:
	template<class T> explicit ___(T &&fun): fun_(std::forward<T>(fun)) {}
	template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template <class Fun> decltype(auto) y_combinator(Fun &&fun) { return ___<std::decay_t<Fun>>(std::forward<Fun>(fun)); }
} // namespace std
#endif

// multidimensional vector
template <int D, class T> struct dvec : public std::vector<dvec<D - 1, T>> { static_assert(D >= 1, "Vector dimension must be greater than zero!"); template <class... Args> dvec(int n, Args... args) : std::vector<dvec<D - 1, T>>(n, dvec<D - 1, T>(args...)) {} };
template <class T> struct dvec<1, T> : public std::vector<T> { dvec(int n, const T &val = T()) : std::vector<T>(n, val) {} };

// adjacent grid coords
// up upright right downright down downleft left upleft
constexpr int dx[] = {-1, -1,  0,  1,  1,  1,  0, -1};
constexpr int dy[] = { 0,  1,  1,  1,  0, -1, -1, -1};

void solveCase(int iTC = 0);
void initialRun();

int main() {
#if FILEIO
#ifdef LOCAL_DEFINE
#warning "FILEIO ON"
#else
	freopen("`!p snip.rv = snip.basename`.inp", "r", stdin);
	freopen("`!p snip.rv = snip.basename`.out", "w", stdout);
#endif
#endif
	std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr);
	std::cout << std::setprecision(12) << std::fixed;

	initialRun();
	int nTC = 1;

#if MULTICASE
#ifdef LOCAL_DEFINE
#warning "MULTICASE ON"
#endif
	(std::cin >> nTC).ignore();
#endif
	for (int iTC = 0; iTC < nTC; iTC++) solveCase(iTC);

	return 0;
}

// constants
constexpr db EPS = 1e-9;
constexpr int INF = 1e9;
constexpr i64 INF64 = 1e18;
constexpr int N = 3e5 + 5;

// *INDENT-ON*
// end of template ====================================================

using namespace std;
#define int i64

void solveCase(int iTC) {
$0
}

// initial run ========================================================
// will run ONCE only before solveCase(), regardless of MULTICASE
void initialRun() {

}
// end of initial run =================================================
endsnippet

snippet fast
// fast ===============================================================
// *INDENT-OFF*
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
static const int buf_size = 4096; static unsigned char buf[buf_size]; static int buf_len = 0, buf_pos = 0;
inline bool isEof() { if (buf_pos == buf_len) { buf_pos = 0, buf_len = fread(buf, 1, buf_size, stdin); if (buf_pos == buf_len) { return 1; } } return 0; }
inline int getChar() { return isEof() ? -1 : buf[buf_pos++]; }
inline int peekChar() { return isEof() ? -1 : buf[buf_pos]; }
inline bool seekEof() { int c; while ((c = peekChar()) != -1 && c <= 32) { buf_pos++; } return c == -1; }
inline void skipBlanks() { while (!isEof() && buf[buf_pos] <= 32U) { buf_pos++; } }
inline int readChar() { int c = getChar(); while (c != -1 && c <= 32) { c = getChar(); } return c; }
inline int readUInt() { int c = readChar(), x = 0; while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return x; }
template <class T = int> inline T readInt() { int s = 1, c = readChar(); T x = 0; if (c == '-') { s = -1, c = getChar(); } else if (c == '+') { c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } return s == 1 ? x : -x; }
inline double readDouble() { int s = 1, c = readChar(); double x = 0; if (c == '-') { s = -1, c = getChar(); } while ('0' <= c && c <= '9') { x = x * 10 + c - '0', c = getChar(); } if (c == '.') { c = getChar(); double coef = 1; while ('0' <= c && c <= '9') { x += (c - '0') * (coef *= 1e-1), c = getChar(); } } return s == 1 ? x : -x; }
inline void readWord(char*s) { int c = readChar(); while (c > 32) { *s++ = c, c = getChar(); } *s = 0; }
inline bool readLine(char*s) { int c = getChar(); while (c != '\n' && c != -1) { *s++ = c, c = getChar(); } *s = 0; return c != -1; }
static int write_buf_pos = 0;
static char write_buf[buf_size];
inline void writeChar(int x) { if (write_buf_pos == buf_size) { fwrite(write_buf, 1, buf_size, stdout), write_buf_pos = 0; } write_buf[write_buf_pos++] = x; }
inline void flush() { if (write_buf_pos) { fwrite(write_buf, 1, write_buf_pos, stdout), write_buf_pos = 0; fflush(stdout); } }
template <class T> inline void writeInt(T x, char end = 0, int output_len = -1) { if (x < 0) { writeChar('-'), x = -x; } char s[24]; int n = 0; while (x || !n) { s[n++] = '0' + x % 10, x /= 10; } while (n < output_len) { s[n++] = '0'; } while (n--) { writeChar(s[n]); } if (end) { writeChar(end); } }
inline void writeWord(const char*s) { while (*s) { writeChar(*s++); } }
inline void writeDouble(double x, int output_len = 0) { if (x < 0) { writeChar('-'), x = -x; } int t = (int)x; writeInt(t), x -= t; writeChar('.'); for (int i = output_len - 1; i > 0; i--) { x *= 10; t = min(9, (int)x); writeChar('0' + t), x -= t; } x *= 10; t = min(9, (int)(x + 0.5)); writeChar('0' + t); }
static struct buffer_flusher_t { ~buffer_flusher_t() { flush(); } } buffer_flusher;
#pragma GCC diagnostic pop
// *INDENT-ON*
// end of fast ========================================================
endsnippet

snippet modint
// modint =============================================================
// *INDENT-OFF*
template <int MOD_> struct modnum {
	static constexpr int MOD = MOD_;
	static_assert(MOD_ > 0, "MOD must be positive");
private:
	using i64 = int64_t; int v;
	static int minv(int a, int m) { a %= m; assert(a); return a == 1 ? 1 : int(m - i64(minv(m, a)) * i64(m) / a); }
public:
	modnum() : v(0) {}
	modnum(i64 v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
	explicit operator int() const { return v; }
	friend ostream& operator << (ostream& out, const modnum& n) { return out << int(n); }
	friend istream& operator >> (istream& in, modnum& n) { i64 v_; in >> v_; n = modnum(v_); return in; }
	
	friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
	friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }
	
	modnum inv() const { modnum res; res.v = minv(v, MOD); return res; }
	friend modnum inv(const modnum& m) { return m.inv(); }
	modnum neg() const { modnum res; res.v = v ? MOD-v : 0; return res; }
	friend modnum neg(const modnum& m) { return m.neg(); }
	
	modnum operator- () const { return neg(); }
	modnum operator+ () const { return modnum(*this); }
	
	modnum& operator ++ () { v ++; if (v == MOD) v = 0; return *this; }
	modnum& operator -- () { if (v == 0) v = MOD; v --; return *this; }
	modnum& operator += (const modnum& o) { v -= MOD-o.v; v = (v < 0) ? v + MOD : v; return *this; }
	modnum& operator -= (const modnum& o) { v -= o.v; v = (v < 0) ? v + MOD : v; return *this; }
	modnum& operator *= (const modnum& o) { v = int(i64(v) * i64(o.v) % MOD); return *this; }
	modnum& operator /= (const modnum& o) { return *this *= o.inv(); }
	
	friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
	friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
	friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
	friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
	friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
	friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
template <class T> T pow(T a, int64_t b) { assert(b >= 0); T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r; }
constexpr int MOD_ = 1e9 + 7;
using imod = modnum<MOD_>;
// *INDENT-ON*
// end of modint ======================================================
endsnippet

snippet katcl
namespace katcl {
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;

// content goes here...
$0

}
using namespace katcl;
endsnippet
